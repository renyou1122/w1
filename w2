from browser import document, html, timer

# --- Constants ---
CELL_SIZE = 40
WALL_THICKNESS = 6
IMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"
ANIMATION_DELAY_MS = 150 # èª¿æ•´å‹•ç•«é€Ÿåº¦

# --- World Class: Handles the visual grid and walls ---
class World:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.layers = self._create_layers()
        self._init_html()
        self._draw_grid()
        self._draw_walls()

    def _create_layers(self):
        # å‰µå»ºå››å€‹ Canvas åœ–å±¤ï¼ŒZ-index è¶Šé«˜è¶Šåœ¨ä¸Šå±¤
        return {
            "grid": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "walls": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "objects": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE), # ç”¨æ–¼ç¹ªè£½ç§»å‹•è»Œè·¡ (trace)
            "robots": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE), # ç”¨æ–¼ç¹ªè£½æ©Ÿå™¨äºº
        }

    def _init_html(self):
        # åˆå§‹åŒ– HTML å®¹å™¨ä¸¦å°‡ Canvas ç–ŠåŠ èµ·ä¾†
        container = html.DIV(style={
            "position": "relative",
            "width": f"{self.width * CELL_SIZE}px",
            "height": f"{self.height * CELL_SIZE}px",
            "border": "2px solid #333",
            "boxShadow": "0 4px 10px rgba(0,0,0,0.1)"
        })
        for z, canvas in enumerate(self.layers.values()):
            canvas.style = {
                "position": "absolute",
                "top": "0px",
                "left": "0px",
                "zIndex": str(z)
            }
            container <= canvas
        document["brython_div1"].clear()
        document["brython_div1"] <= container

    def _draw_grid(self):
        # ç¹ªè£½ç°è‰²ç¶²æ ¼ç·š
        ctx = self.layers["grid"].getContext("2d")
        ctx.strokeStyle = "#cccccc"
        for i in range(self.width + 1):
            ctx.beginPath()
            ctx.moveTo(i * CELL_SIZE, 0)
            ctx.lineTo(i * CELL_SIZE, self.height * CELL_SIZE)
            ctx.stroke()
        for j in range(self.height + 1):
            ctx.beginPath()
            ctx.moveTo(0, j * CELL_SIZE)
            ctx.lineTo(self.width * CELL_SIZE, j * CELL_SIZE)
            ctx.stroke()

    def _draw_image(self, ctx, src, x, y, w, h, offset_x=0, offset_y=0):
        # ç¹ªè£½åœ–ç‰‡çš„è¼”åŠ©å‡½æ•¸ï¼Œè™•ç†åœ–ç‰‡è¼‰å…¥å’Œåº§æ¨™è½‰æ›
        # Reeborg åº§æ¨™ (x, y) è½‰ Canvas åƒç´  (px, py)
        img = html.IMG()
        img.src = src
        def onload(evt):
            px = x * CELL_SIZE + offset_x
            # è½‰æ› Y è»¸ï¼šReeborg (1,1) æ˜¯å·¦ä¸‹è§’ï¼ŒCanvas (0,0) æ˜¯å·¦ä¸Šè§’
            py = (self.height - 1 - y) * CELL_SIZE + offset_y
            ctx.drawImage(img, px, py, w, h)
        img.bind("load", onload)

    def _draw_walls(self):
        # ç¹ªè£½ä¸–ç•Œçš„å››é€±é‚Šç•Œç‰†
        ctx = self.layers["walls"].getContext("2d")
        # åŒ—ç‰† (ä¸Šé‚Šç•Œ)
        for x in range(self.width):
            self._draw_image(ctx, IMG_PATH + "north.png", x, self.height - 1,
                             CELL_SIZE, WALL_THICKNESS, offset_y=0)
        # å—ç‰† (ä¸‹é‚Šç•Œ)
        for x in range(self.width):
            self._draw_image(ctx, IMG_PATH + "north.png", x, 0,
                             CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE - WALL_THICKNESS)
        # è¥¿ç‰† (å·¦é‚Šç•Œ)
        for y in range(self.height):
            self._draw_image(ctx, IMG_PATH + "east.png", 0, y,
                             WALL_THICKNESS, CELL_SIZE, offset_x=0)
        # æ±ç‰† (å³é‚Šç•Œ)
        for y in range(self.height):
            self._draw_image(ctx, IMG_PATH + "east.png", self.width - 1, y,
                             WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE - WALL_THICKNESS)

# --- AnimatedRobot Class: Handles robot state, movement queue, and drawing ---
class AnimatedRobot:
    def __init__(self, world, x, y):
        self.world = world
        # Reeborg åº§æ¨™ (1, 1) å°æ‡‰å…§éƒ¨é™£åˆ—åº§æ¨™ (0, 0)
        self.x = x - 1
        self.y = y - 1
        self.facing = "E" # E, N, W, S (æ±, åŒ—, è¥¿, å—)
        self.facing_order = ["E", "N", "W", "S"]
        self.robot_ctx = world.layers["robots"].getContext("2d")
        self.trace_ctx = world.layers["objects"].getContext("2d")
        self.queue = [] # å„²å­˜å‹•ä½œåºåˆ—
        self.running = False
        self._draw_robot()

    def _robot_image(self):
        # æ ¹æ“šæœå‘æ±ºå®šåœ–ç‰‡åç¨±
        return {
            "E": "blue_robot_e.png",
            "N": "blue_robot_n.png",
            "W": "blue_robot_w.png",
            "S": "blue_robot_s.png"
        }[self.facing]

    def _draw_robot(self):
        # æ¸…é™¤æ©Ÿå™¨äººåœ–å±¤ï¼Œä¸¦åœ¨æ–°çš„ä½ç½®é‡ç¹ªæ©Ÿå™¨äºº
        self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)
        self.world._draw_image(self.robot_ctx, IMG_PATH + self._robot_image(),
                               self.x, self.y, CELL_SIZE, CELL_SIZE)

    def _draw_trace(self, from_x, from_y, to_x, to_y):
        # ç¹ªè£½ç§»å‹•è»Œè·¡
        ctx = self.trace_ctx
        ctx.strokeStyle = "#4CAF50" # ç¶ è‰²è»Œè·¡
        ctx.lineWidth = 3
        
        # å°‡ grid åº§æ¨™è½‰æ›ç‚º Canvas ä¸­å¿ƒé»åƒç´ åº§æ¨™
        fx = from_x * CELL_SIZE + CELL_SIZE / 2
        fy = (self.world.height - 1 - from_y) * CELL_SIZE + CELL_SIZE / 2
        tx = to_x * CELL_SIZE + CELL_SIZE / 2
        ty = (self.world.height - 1 - to_y) * CELL_SIZE + CELL_SIZE / 2
        
        ctx.beginPath()
        ctx.moveTo(fx, fy)
        ctx.lineTo(tx, ty)
        ctx.stroke()

    def move(self, steps):
        # å°‡ç§»å‹•å‹•ä½œåŠ å…¥ä½‡åˆ—
        def action(next_done):
            def step():
                nonlocal steps
                if steps == 0:
                    next_done()
                    return

                from_x, from_y = self.x, self.y
                dx, dy = 0, 0
                if self.facing == "E":
                    dx = 1
                elif self.facing == "W":
                    dx = -1
                elif self.facing == "N":
                    dy = 1
                elif self.facing == "S":
                    dy = -1
                
                next_x = self.x + dx
                next_y = self.y + dy
            
                # é‚Šç•Œæª¢æŸ¥ï¼šæª¢æŸ¥ä¸‹ä¸€æ­¥æ˜¯å¦åœ¨ä¸–ç•Œç¯„åœå…§
                if 0 <= next_x < self.world.width and 0 <= next_y < self.world.height:
                    self.x, self.y = next_x, next_y
                    self._draw_trace(from_x, from_y, self.x, self.y)
                    self._draw_robot()
                    steps -= 1
                    timer.set_timeout(step, ANIMATION_DELAY_MS)
                else:
                    # å¦‚æœæ’ç‰†ï¼Œåœæ­¢ç§»å‹•ä¸¦å®Œæˆç•¶å‰å‹•ä½œ
                    print("ğŸš¨ å·²ç¶“æ’ç‰†ï¼Œåœæ­¢ç§»å‹•ï¼")
                    next_done()
            step()
        self.queue.append(action)
        self._run_queue()

    def turn_left(self):
        # å·¦è½‰ (E -> N -> W -> S -> E)
        def action(done):
            idx = self.facing_order.index(self.facing)
            self.facing = self.facing_order[(idx + 1) % 4]
            self._draw_robot()
            timer.set_timeout(done, ANIMATION_DELAY_MS)
        self.queue.append(action)
        self._run_queue()

    def turn_right(self):
        # å³è½‰ (E -> S -> W -> N -> E)
        def action(done):
            idx = self.facing_order.index(self.facing)
            # è² æ•¸å–æ¨¡é‹ç®—ï¼Œç¢ºä¿çµæœç‚ºæ­£
            self.facing = self.facing_order[(idx - 1 + 4) % 4] 
            self._draw_robot()
            timer.set_timeout(done, ANIMATION_DELAY_MS)
        self.queue.append(action)
        self._run_queue()

    def _run_queue(self):
        # è™•ç†å‹•ä½œä½‡åˆ—
        if self.running or not self.queue:
            return
        self.running = True
        action = self.queue.pop(0)
        action(lambda: self._done())

    def _done(self):
        # ç•¶å‰å‹•ä½œå®Œæˆï¼Œç¹¼çºŒåŸ·è¡Œä¸‹ä¸€å€‹å‹•ä½œ
        self.running = False
        self._run_queue()

# --- ä¸»ç¨‹å¼åŸ·è¡Œå€å¡Š (å‚ç›´å·¡é‚é‚è¼¯) ---
# 1. å»ºç«‹ 10x10 çš„ä¸–ç•Œ
w = World(10, 10)
# 2. åœ¨ (1, 1) æ”¾ç½®æ©Ÿå™¨äºº
r = AnimatedRobot(w, 1, 1) # æ©Ÿå™¨äººé è¨­æœæ± (E)

# 2.5: è®“æ©Ÿå™¨äººä¸€é–‹å§‹æœåŒ— (N)ï¼Œæº–å‚™å‚ç›´å‘ä¸Šç§»å‹•
r.turn_left() # E -> N

# 3. å¯¦ç¾å‚ç›´å·¡é‚ (S å­—å½¢) é‚è¼¯
steps_to_move = w.height - 1 # 9 æ­¥æ‰èƒ½èµ°å®Œ 10 æ ¼é«˜åº¦

# è¿´åœˆéæ­·æ‰€æœ‰ X åº§æ¨™çš„åˆ— (x=0 åˆ° x=9)
for i in range(w.width):
    is_moving_north = (i % 2 == 0) # å¶æ•¸åˆ— (0, 2, 4...) å‘åŒ—èµ° (ä¸Š)

    # æ­¥é©Ÿ A: å‚ç›´ç§»å‹• (9 æ­¥)
    r.move(steps_to_move)

    # æ­¥é©Ÿ B: è½‰å‘ä¸¦æ°´å¹³ç§»å‹• 1 æ­¥åˆ°ä¸‹ä¸€åˆ— (å¦‚æœä¸æ˜¯æœ€å¾Œä¸€åˆ—)
    if i < w.width - 1:
        if is_moving_north:
            # å¶æ•¸åˆ—: èµ°å®Œ (y=0->9, x=i)ï¼Œé¢å‘ N (ä¸Š)ã€‚
            # è½‰å‘ E (å³è½‰)ï¼Œç§»å‹• 1 æ­¥ E (å³)ï¼Œè½‰å‘ S (å³è½‰)
            r.turn_right() # N -> E
            r.move(1)      # ç§»åˆ° (x=i+1, y=9)
            r.turn_right() # E -> S (æº–å‚™å¾€ä¸‹èµ°)
        else:
            # å¥‡æ•¸åˆ—: èµ°å®Œ (y=9->0, x=i)ï¼Œé¢å‘ S (ä¸‹)ã€‚
            # è½‰å‘ E (å·¦è½‰)ï¼Œç§»å‹• 1 æ­¥ E (å³)ï¼Œè½‰å‘ N (å·¦è½‰)
            r.turn_left()  # S -> E
            r.move(1)      # ç§»åˆ° (x=i+1, y=0)
            r.turn_left()  # E -> N (æº–å‚™å¾€ä¸Šèµ°)

# å·¡é‚å®Œæˆå¾Œï¼Œå¯ä»¥è®“æ©Ÿå™¨äººå†è½‰å‘ (ä¾‹å¦‚è½‰å‘æ±E)
r.turn_right()
print("ğŸ¤– å‚ç›´å·¡é‚è·¯å¾‘ç¹ªè£½å®Œæˆï¼")
